#lang racket

#|====================================================================================================

(procedure : (sudoku ‹str›) --> void?
‹str› : string as described below

The string must contain 81 elements separated by white space.
An element must not contain white space.
A digit is a natural number n (<= 1 n 9).
Each element other than digit represents the absence of a digit.
An absent or non-digit is printed as `•´.
All solutions are computed and printed.

A completed sudoku board has 81 fields in 9 rows and 9 colums,
each field containing a digit n (<= 1 n 9), however with the following restrictions:
  A column or row must not contain a duplicate digit.
  There are 9 disjunct subboards of 3 by 3 adjacent rows/columns and
  no duplicate digit is allowed in a subboard.

Argument ‹str› is checked to satisfy the restrictions.
Can we prove that when the restrictions are satisfied, there always is at least one solution?
In a solution each column, each row and each 3x3 subsquare must contain a permutation of the digits
1 up to and including 9. 

There are 6670903752021072936960 fully completed boards.
Theoretically they can be generated by calling procedure sudoku without any digit specified,
but in practice the large number makes this impossible.

======================================================================================================

A board is represented by a vector of 81 natural numbers d (<= 0 n 9),
0 indicating the absence of a digit.
An index is a natural number i (<= 0 i 80).
A digit is a natural number d (<= 1 d 9).
Rows and columns are indexed by digits.

====================================================================================================|#

(define in-index (range 81))
(define in-digit (range 1 10))
(define (digit? d) (and (natural? d) (<= 1 d 9)))

(define (make-board (fill 0))
  (cond
    ((procedure? fill)
     (define board (make-board))
     (for ((index in-index)) (board-set! board index (fill index)))
     board)
    (else (make-vector 81 fill))))

(define (row/col->index row col)
  (+ (* 9 (sub1 row)) (sub1 col)))

(define (index->row/col index)
  (let-values (((r c) (quotient/remainder index 9)))
    (values (add1 r) (add1 c))))

(define (index->row+col index)
  (let-values (((r c) (quotient/remainder index 9)))
    (list (add1 r) (add1 c))))

(define board-ref
  (case-lambda
    ((board row col) (vector-ref board (row/col->index row col)))
    ((board index) (vector-ref board index))))

(define board-set!
  (case-lambda
    ((board row col value) (vector-set! board (row/col->index row col) value))
    ((board index value) (vector-set! board index value))))

(define (list->board lst)
  (define board (make-board))
  (for ((index in-index) (elem (in-list lst))) (board-set! board index elem))
  board)

(define (index->mutable-seteqv index) (mutable-seteqv))

(define neighbours
  (let ((board (make-board index->mutable-seteqv)))
    (for* ((row in-digit) (col in-digit))
      (for ((r in-digit) #:unless (= r row))
        (set-add! (board-ref board row col) (row/col->index r col)))
      (for ((c in-digit) #:unless (= c col))
        (set-add! (board-ref board row col) (row/col->index row c)))
      (let*
        ((r (add1 (* 3 (quotient (sub1 row) 3))))
         (c (add1 (* 3 (quotient (sub1 col) 3)))))
        (for* ((r (in-range r (+ r 3))) (c (in-range c (+ c 3))) #:unless (and (= r row) (= c col)))
          (set-add! (board-ref board row col) (row/col->index r c)))))
    board))

(define (board-string? obj)
  (and (string? obj)
    (= (count (compose not char-whitespace?) (string->list obj)) 81)))

(define (read-board str)
  (unless (board-string? str) (raise-argument-error 'read-board "board-string?" str))
  (define board (make-board))
  (define input (open-input-string str))
  (for ((index in-index))
    (define d (read input))
    (when (digit? d)
      (define ns (board-ref neighbours index))
      (for ((n (in-set ns)))
        (when (eqv? d (board-ref board n))
          (error 'read-board "neigbouring digit: ~s ~s ~s" d index n)))
      (board-set! board index d)))
  board)

(define (print-board board)
  (for ((row in-digit))
    (for ((col in-digit))  (printf "~s " (convert-zero (board-ref board row col))))
    (newline))
  (newline))

(define (convert-zero d) (if (digit? d) d '•))

(define (solve board)
  (define nr-of-solutions 0)
  (define (solve open)
    (let loop ((open open))
      (cond
        ((null? open) (print-board board) (set! nr-of-solutions (add1 nr-of-solutions)))
        (else
          (define index (car open))
          (unless (digit? (board-ref board index))
            (for ((d in-digit))
              (unless (yet-in-neighbour? d index board)
                (board-set! board index d)
                (loop  (cdr open))
                (board-set! board index 0))))))))
  (solve (for/list ((index in-index) #:unless (digit? (board-ref board index))) index))
  nr-of-solutions)

(define (show x) (println x) x)

(define (yet-in-neighbour? d index board)
  (for/or ((i (in-set (board-ref neighbours index))))
    (= (board-ref board i) d)))

(define (sudoku str)
  (displayln "Starting sudoku:\nInitial board:\n")
  (define board (read-board str))
  (print-board board)
  (displayln "Solutions:\n")
  (define-values (n cpu real gc) (time-apply solve (list board)))
  (printf "Finishedu:\nNr of solutions: ~s~nCPU time: about ~a seconds~n~n"
    (car n) (~r #:precision 3 (/ cpu 1000))))

;=====================================================================================================

(sudoku
  "1 2 3   4 5 6   7 8 9
   4 5 6   7 8 9   1 2 3
   7 8 9   1 2 3   4 5 6

   2 3 1   5 6 4   8 9 7
   5 6 4   8 9 7   2 3 1
   8 9 7   2 3 1   5 6 4

   3 1 2   6 4 5   9 7 8
   6 4 5   9 7 8   3 1 2
   9 7 8   3 1 2   6 4 5
")

(sudoku
  "1 2 3   4 5 6   7 8 9
   4 5 6   7 8 9   1 2 3
   7 8 9   1 2 3   4 5 6

   2 3 1   5 6 4   8 9 7
   5 6 4   8 9 7   2 3 1
   8 9 7   2 3 1   5 6 4

   3 1 2   6 4 5   9 7 8
   • • •   • • •   • • •
   • • •   • • •   • • •")
     
(sudoku
  "1 2 3   4 5 6   7 8 9
   4 5 6   7 8 9   1 2 3
   7 8 9   1 2 3   4 5 6

   2 3 1   5 6 4   8 9 7
   5 6 4   8 9 7   2 3 1
   8 9 7   2 3 1   5 6 4

   3 1 2   6 4 5   9 7 8
   • • •   • • •   3 1 2
   • • •   • • •   • • •")
     
(sudoku
  "1 2 3   4 5 6   7 8 9
   4 5 6   7 8 9   1 2 3
   7 8 9   1 2 3   4 5 6

   2 3 1   5 6 4   8 9 7
   5 6 4   8 9 7   2 3 1
   8 9 7   2 3 1   5 6 4

   3 1 2   6 4 5   9 7 8
   • • •   • • •   3 • •
   • • •   • • •   • • •")

(sudoku
  "• • •   5 2 4   • • 6
   9 3 •   • • •   • 7 •
   • • •   • • •   • • •
   • • •   • • 3   • • •
   2 8 •   • • •   • • •
   • • 1   7 • •   4 • •
   • • •   6 • •   1 • 7
   • 9 •   • • •   • 2 •
   • • 4   • 8 •   • 3 •")

(sudoku
  "5 3 •   • 7 •   • • •
   6 • •   1 9 5   • • •
   • 9 8   • • •   • 6 •
   8 • •   • 6 •   • • 3
   4 • •   8 • 3   • • 1
   7 • •   • 2 •   • • 6
   • 6 •   • • •   2 8 •
   • • •   4 1 9   • • 5
   • • •   • 8 •   • 7 9")

(sudoku
  "5 3 •   • 7 •   • • •
   6 • •   1 9 5   • • •
   • 9 8   • • •   • 6 •
   8 • •   • 6 •   • • 3
   4 • •   8 • 3   • • 1
   7 • •   • 2 •   • • 6
   • 6 •   • • •   2 8 •
   • • •   4 1 9   • • •
   • • •   • 8 •   • • •")

(sudoku
  "8 • •   • • •   • • •
   • • 3   6 • •   • • •
   • 7 •   • 9 •   2 • •
   • 5 •   • • 7   • • •
   • • •   • 4 5   7 • •
   • • •   1 • •   • 3 •
   • • 1   • • •   • 6 8
   • • 8   5 • •   • 1 •
   • 9 •   • • •   4 • •")


#;
(sudoku
  "1 2 3   4 5 6   7 8 9
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   • • •   • • •   • • •
   ")

;=====================================================================================================
